--------
| Task |
--------
[ ] add handling error.
[ ] fix file comments.
[ ] add function comments.
[ ] make console.
[ ] add panic function.
[ ] fix vmalloc and related function.



--------
| Memo |
--------
clang option for cross compile
lib32-glibc-2.14-4
wc -l ./*.c ./*/*.c ./*.asm ./*/*.asm

a=0;foreach f (`find . -name "*.c" -o -name "*.asm"`)
e=$(du -b $f | sed 's/^\([0-9]*\).*/\1/g')
a=$((a+e))
end; echo "$((a/1024))kb"



------------
| Thinking |
------------

メモリ管理
    pmalloc - physical memory allocation
        物理メモリ管理
    vmalloc - virtual memory allocation
        仮想メモリ管理
    pfmap - page and frame mapping
        仮想/物理メモリマッピング
    umalloc - user memory allocation
        すでにマッピングされ有効な、ユーザ権限の仮想メモリ
    kmalloc - kernel memory allocation
        すでにマッピングされ有効な、カーネル権限の仮想メモリ

    kmalloc -> vmalloc + map_page(kernel) -> pmalloc
    umalloc -> vmalloc + map_page(user)   -> pmalloc
        umallocはユーザ空間におけるmallocに相当するのでOSの実装には不要では
        なので、テキストセグメントとデータセグメントの操作、スワッピングなどがいい感じにできればよいはず
    vmalloc + map_page(kernel) -> pmalloc
    これだけでいいかな

    ユーザ空間の初期化
        一時的に初期化したいユーザ空間と同じフレームをカーネル空間にマップする
            TLBフラッシュのコストが少し多い. -> メモリ使用量、マルチプログラミングの実装の観点からいまいち？
        ユーザpdtの末尾をカーネル空間と同じにし、pdtのみユーザ用に切り替えて、初期化用のカーネルコードを走らせる
            初期化中にカーネルスレッドが切り替わり、メモリ関連の処理が走ったら整合性が崩れる?
                ユーザpdtが常にカーネルpdtを持てばよい？
                カーネルpdtは常に(3~4GB)固定.
                ユーザpdtは(0~3GB)固定

                CR3にセットされているpdt
                --------------------------------
                |         User          |Kernel|
                --------------------------------
                0                       3      4 [GB]
                おそらくpdt内のエントリは物理メモリ上で連続ではなければならないので
                カーネルpdtに変更があったらそれをユーザpdtに反映させる
                    linuxのようにPagefaultを利用して反映が一番良さそう
                    処理の遅延なので、よさ気
                こうすることでカーネルコードを実行するときのTLBフラッシュを避けられる
                このようにして、カーネルメモリ確保の時に、現在のpdtを参照するようにすれば整合性は大丈夫そう

    理想的実装
    物理メモリ管理 - バディシステム
    仮想メモリ管理 - スラブアロケータ
    バディシステムが(2^n * FRAME_SIZE)単位で物理メモリを管理.
        ex. 4KB, 8KB, 16KB, 32KB...
    これでは断片化が激しい
    また、物理メモリ管理のみでは使えないので、ページングをする際の管理方式として
    スラブアロケータを利用することで、断片化を回避する.
    具体的にはバディシステムから取得したメモリを、より細かい単位で、管理、割り当てするようにする.
        ex. バディシステムのみだと、1KBのメモリ要求があった際、4KB分の領域を確保するため、3KB無駄になる
            スラブアロケータでは、メモリプールを用いて、適切に1KB分のみ返すようにする.



ユーザ空間の実現にあたって
    ユーザ空間管理方法
        プロセス毎にページディレクトリテーブルを持たせる
        各プロセスは独自のページディレクトリテーブルを持つことでメモリ空間が独立する
        カーネルプロセスは唯一のものとする
            ただしカーネルスレッドは複数存在出来る.
        その時のページアウト、ページイン方法について
            ページアウト -> 全ユーザプロセスを走査して、対象を決める
                            ページの前に、対象プロセスを決めて、その中から更にページを決める
            ページイン   -> ページアウト時にプロセスの持つページディレクトリテーブルにその旨を書き込んでおく
                            それを元にスワップ先を判定して、復帰する.
    ユーザ、カーネル間のコンテキストスイッチ方式
        Linuxを真似て、各プロセスにカーネルスタックを設けるか？ -> 切り替えコストが低い
    ブート時のプロセス初期化手順
        カーネルプロセス初期化 -> ユーザプロセス生成
    カーネル -> ユーザへのスイッチング
